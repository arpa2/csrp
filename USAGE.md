# SRP #11 Usage Scheme

> *This document explains how the use of SRP #11 differs from plain SRP.*

The use of SRP #11 only changes the client side; the server continues to use
the formalism that it has always used.  The benefits on the client side are
tremendous -- since SRP is a zero-knowledge proof (and so in SRP #11) the
benefit of storing key material behind a protective PKCS #11 barrier provides
a complete inability to authenticate without the token.

## Using PKCS #11

The mechanism will generate a key pair on a PKCS #11 token.  The two keys are
always used together, and only on the client side, so they span two objects
but may actually be considered one composite key.  They public half however,
can stand publication -- it just won't help anyone.  The private half must
be protected as is customary, and PKCS #11 will do what it can to make that
happen.

When the key is created, we pass in the N,g parameters for the algorithm,
that is, the modulus and generator.  These may be standard values from
RFC 5054, Appendix A, or they may be user-supplied.  Based on these values,
a random private key will be generated and the corresponding public key
will be derived.  The resulting PKCS #11 objects contain the N,g values
which therefore do not need to be passed in anymore.

The applicaion is supposed to open a PKCS #11 session and login, and supply
the two keys upon later use.  To that end, it is possible to supply parameters
to the generation process alongside the N,g values.  These parameters are
usually `CKA_ID` and `CKA_LABEL`.  The N,g values are supplied seperately, so
as to simplify access to the standardised N,g values, but they end up in
the `CKA_PRIME` and `CKA_BASE` attributes which the calling application isn't
supposed to set.  Other things the application shouldn't touch while
generating keys are `CKA_CLASS` and `CKA_KEY_TYPE`.

By default the keys will be session keys of which the private key will be
stored as sensitive.  To create lasting keys, set `CKA_TOKEN` to CK_TRUE and
other flags that may be valued include `CKA_WRAP` and `CKA_UNWRAP`.
Have a ball!

To use the keys again at a later time, use PKCS #11 functionality to look
them up, and provide them.  There are a few extra things you can select them
on, namely `CKA_KEY_TYPE` is set to `CKK_DH` and the public key has
`CKA_CLASS` set to `CKO_PUBLIC_KEY` while the private key has it set to
`CKO_PRIVATE_KEY`.

Note how the username never comes into play for there functions.  You are
advised to setup `CKA_LABEL` and/or `CKA_ID` to hold this information, with
or without additional information that you can use (such as an indication
of the hash algorithm used).  Precisely how the username is encoded in terms
of PKCS #11 is left to the SRP #11 application.

## Creating a verifier and salt

The function to create a new salt,verifier pair is a standalone call that
takes a key pair and some additional information.  It is possible to
supply the function with a pregenerated salt, which must then at least be
of the size of the hash algorithm used, but more is possible.  Bytes beyond
the hash size have no cryptographic gain because they add no entropy, but
since it is hashed along with the rest its contents are part of the proof
of identity between the client and server, so it is possible to store some
information there, possibly to identify the server.  We're talking about
a form of pinning, cryptographically tied into the salt.  This could even be
considered a client-generated "certificate" in any format that the client
likes, and that it can use to validate the server!

If the salt is not supplied to the generation function for the salt,verifier
then it will be allocated by the function, to the size of the hash function,
and filled with random bytes generated by PKCS #11.  Note that it is possible
to influence the entropy of the PKCS #11 random number generator with a seed,
using standard PKCS #11 functions.

The verifier is always allocated by the generator function, and the client is
always responsible of free()ing both the salt and the verifier.  Their contents
have a separately relayed length in bytes, and these hold the binary values
for the salt and verifier as they are needed for the protocol.

## Authenticating towards a server

To authenticate towards a server, the client must go through a number of steps,
each represented by a function call.  The values used between those steps
are stored in an SRP11User structure.  These include the PKCS #11 session and
its public and private key handles, and protocol values such as *v*, *a* and
*M*, and of course the agreed-up session key *K*.  In addition, it holds a
flag that indicates whether authentication has succeeded.

The calculation does of course make use of the private key, and it somehow
integrates the salt, and not just to derive the verifier.  And it incorporates
random material passed in from the server, as well as passing out random
material to the server.  All this is needed to construct a proof in a way
that requires access to PKCS #11 or, in other words, access to the token.

## Cost of efficiency, benefit of security

The authentication mechanism of SRP #11 is based on a slightly different
formalism than for customary SRP, at least at the client side.  This is in
the interest of truly relying on the token, and care has been taken during
the generation of salt,verifier to make the presence of the token a necessity
without letting PKCS #11 users derive information from which they could
reconstruct the private key.  The result is that more of the relatively
expensive modular-exponentiation operations are needed, resulting in somewhat
slower authentication than with plain SRP.  This is the price of the
heightened security level due to reliance of a hardware token; two-factor
security simply comes at a higher computational expense than one-factor
security.

Note that the shared key that a protocol can use for encryption of data
traffic is not derived (and kept) inside the token.  This means that it is
not possible to reliably use a totally untrusted desktop.  The one thing
we can promise (for a well-designed PKCS #11 hardware token) is that the
private key needed for authentication cannot be pulled off of it, but there
is no way to guarentee data privacy or even protect against additional
authentications while a token is plugged into an unsafe environment, with
the token PIN supplied.

